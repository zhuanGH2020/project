# Unity 3D Game Development Cursor Rules
# 适用于Unity 2021.3.37f1，3D游戏开发，PC平台

## Unity项目规范

### Unity命名约定
- **类名**: PascalCase，如 `PlayerController`, `InventoryManager`
- **公共变量和属性**: PascalCase，如 `Health`, `MaxSpeed`
- **私有变量**: camelCase + 下划线前缀，如 `_health`, `_isGamePaused`
- **方法名**: PascalCase，如 `StartGame()`, `UpdateHealth()`
- **常量**: UPPER_SNAKE_CASE，如 `MAX_HEALTH`, `DEFAULT_SPEED`
- **枚举**: PascalCase，如 `ActorType`, `ObjectState`
- **接口名**: 以I开头，如 `IDamageable`, `IInteractable`
- **文件名**: 与类名一致，如 `PlayerController.cs`
- **命名空间**: PascalCase，项目层级结构，如 `GameProject.Core.Manager`
- **所有公共方法和类**: 必须有XML文档注释（/// <summary>）

## Unity特定规范

### MonoBehaviour规范
- 每个MonoBehaviour只负责一个明确的功能
- 使用 `[SerializeField]` 而不是 `public` 暴露字段
- 使用 `[Header]`, `[Tooltip]` 等特性改善Inspector体验
- 使用 `[Range]` 属性限制数值范围
- 重写 `Awake()`, `Start()`, `Update()` 时调用基类方法
- 缓存Transform等组件提升性能
- 使用事件系统进行组件间通信

### 组件设计
- 优先使用组合而非继承
- 每个组件职责单一，便于测试和复用
- 避免在Update中频繁查找组件
- UI系统遵循MVC模式分离关注点
- 游戏系统使用Manager模式管理

### 性能优化
- 缓存GetComponent结果
- 使用Object Pooling管理频繁创建销毁的对象
- 避免在Update中进行字符串操作
- 使用协程处理延时操作
- 合理使用LOD系统
- 优化渲染：合理使用光照贴图和动态光照
- 资源加载：根据需要实现分块加载和异步加载

## 项目架构

### 架构设计
- **UI系统**: 使用MVC模式，分离数据、视图和控制逻辑
- **游戏系统**: 使用Manager模式，每个系统由专门的Manager管理
- **Actor系统**: 统一管理所有Actor，支持主角和怪物等不同类型
- **Object系统**: 统一管理所有可交互Object，包括物品、建筑、工具等

### 文件夹结构
```
Assets/
├── Script/          # 所有脚本
│   ├── Core/         # 核心系统
│   │   ├── Enums.cs  # 枚举定义
│   │   ├── Resource/ # 资源管理
│   │   │   └── ResourceManager.cs  # 资源加载管理
│   │   ├── Pool/     # 对象池系统
│   │   │   ├── ObjectPoolManager.cs  # 对象池管理器
│   │   │   └── ObjectPool.cs         # 对象池
│   │   ├── Event/    # 事件系统
│   │   │   ├── EventManager.cs       # 全局事件管理器
│   │   │   └── EventDefinition.cs    # 事件定义
│   │   └── Config/   # 配置系统
│   │       ├── ConfigDefinition.cs    # 配置定义
│   │       ├── ConfigManager.cs       # 配置管理器
│   │       ├── ConfigReader.cs        # 配置读取器
│   │       └── Example/              # 示例代码
│   │           └── ConfigExample.cs   # 使用示例
│   ├── Actor/        # Actor系统
│   ├── Object/      # Object系统
│   ├── UI/           # UI系统（MVC架构）
│   ├── Manager/     # 管理器
│   └── Utils/        # 工具类
├── Res/        # 资源文件（由ResourceManager管理）
│   ├── Scene/       # 场景
│   ├── Prefab/      # 预制体
│   ├── Material/    # 材质
│   ├── Texture/     # 贴图
│   ├── Model/       # 模型
│   └── Audio/        # 音频
└── Plugins/          # 插件
```

### 核心系统设计

#### 资源管理系统
- **ResourceManager**: 资源加载管理
  - 资源加载：同步/异步加载
  - 引用计数：跟踪资源引用，自动卸载
  - 资源缓存：已加载资源的缓存管理

#### 对象池系统
- **ObjectPoolManager**: 对象池管理器
  - 分类管理：不同类型对象使用不同对象池
  - 统一接口：提供对象获取和回收的统一接口
  - 生命周期：管理各个对象池的生命周期
  - **管理范围**：统一管理Actor和Object两大系统的对象池

- **ObjectPool**: 对象池
  - 对象复用：减少实例化/销毁开销
  - 多预制体支持：一个池可以管理多种预制体
  - 对象状态管理：自动重置对象状态
  - 超时清理：自动清理长时间未使用的对象

#### 配置系统
- **ConfigManager**: 配置管理器
  - 配置加载：加载CSV和ScriptableObject配置
  - 配置缓存：缓存已加载的配置
  - 配置查询：提供统一的查询接口
  - 配置清理：支持清理单个或所有配置

- **ConfigReader**: 配置读取器
  - 数据解析：解析配置数据
  - 类型转换：支持多种数据类型
  - 错误处理：提供友好的错误提示
  - 默认值：支持默认值返回

- **ConfigDefinition**: 配置定义
  - 表头解析：解析CSV表头信息
  - 类型验证：验证数据类型有效性
  - 支持基础类型、数组类型、枚举类型和Unity类型

#### 事件系统
- **统一事件架构**：所有系统间通信使用统一的事件机制
- **事件类型**：
  - UnityEvent：UI组件和MonoBehaviour内部事件
  - System.Action/Func：纯C#类之间的事件通信
  - 全局事件管理器：用于系统级事件广播和订阅
- **事件命名规范**：On + 动作 + 结果，如 OnHealthChanged, OnItemPickedUp
- **事件生命周期**：订阅时注册，销毁时必须取消订阅避免内存泄漏
- **事件管理器设计**：提供统一的事件注册、广播、取消订阅接口

#### 管理器系统
- **Manager文件夹**: 存放各类游戏系统管理器
- **设计原则**：每个系统由专门的Manager管理
- **核心管理器**：
  - ActorManager：Actor系统管理
  - ObjectManager：Object系统管理  
  - UIManager：UI系统管理
  - 其他管理器：根据游戏需求扩展（如AudioManager、InputManager等）
- **管理器职责**：
  - 统一管理对应系统的所有实例
  - 提供系统的创建、销毁、查询接口
  - 处理系统级的业务逻辑
  - 与其他管理器通过事件系统通信

#### 工具类系统
- **Utils文件夹**: 存放通用工具类和辅助方法
- **功能范围**: 数学计算、字符串处理、扩展方法等
- **设计原则**: 静态方法为主，无状态，可复用

### UI系统MVC实现规范
- **UI模块化设计**:
  - 每个UI功能模块独立，有自己的Model/View/Controller
  - 模块间通过事件系统通信，避免直接依赖
  - 每个模块可以独立开发、测试和维护

- **UI Model层**:
  - 每个模块只有一个Model类
  - 纯数据类，存储UI状态和数据
  - 不包含MonoBehaviour
  - 通过事件通知UI View层更新
  - 与游戏业务系统交互获取数据

- **UI View层**:
  - 可以有多个View组件
  - 负责UI界面显示和动画
  - 监听UI Model层事件进行更新
  - 不包含业务逻辑，只负责展示
  - 使用MonoBehaviour组件

- **UI Controller层**:
  - 每个模块只有一个Controller类
  - 处理UI用户输入和交互
  - 更新UI Model层数据
  - 协调UI Model和UI View之间的交互
  - 与游戏业务系统通信（如ActorManager、ObjectManager等）

### 数据管理规范
- **CSV配置**: 用于大量结构化数据，支持外部工具编辑
  - 游戏实体属性数据（Actor、Object等）  
  - 系统配置数据（技能、效果等）
  - 关系映射数据（掉落、制作等）
- **ScriptableObject配置**: 用于游戏平衡参数和预设数据
- **存档数据**: 使用JSON文件存储游戏进度和状态
- **配置加载策略**：
  - 游戏启动时预加载ScriptableObject配置
  - 运行时按需加载CSV数据
  - 优先使用ScriptableObject，大量数据使用CSV

## 游戏系统规范

### Actor系统
- **ActorManager**统一管理所有Actor
- **Actor分类**:
  - ActorMain (主角)：玩家控制的Actor
  - Monster (怪物)：敌对AI的Actor
  - 其他Actor类型：Partner、NPC等可根据需要扩展
- **Actor组件化设计**:
  - 每个Actor由多个组件组成
  - 组件可复用，便于组合不同Actor
  - 使用接口定义通用行为
- **Actor生命周期管理**:
  - 统一的对象池管理
  - Actor的创建、激活、休眠、销毁
  - 支持Actor的状态保存和恢复
- **状态机和Buff系统**:
  - 支持状态机接口 `IActorStateMachine`
  - 支持Buff系统接口 `IBuffSystem`
  - 提供统一的扩展接口
  - 状态机用于管理Actor的行为状态转换
  - Buff系统用于管理Actor的临时效果和属性修改

### Object系统
- **ObjectManager**统一管理所有可交互Object
- **Object分类**:
  - Items (物品)：可收集、使用的道具类Object
  - Buildings (建筑)：可建造、放置的结构物Object
  - Tools (工具)：可装备、使用的工具类Object
  - 其他Object类型：根据游戏需求可扩展更多类型
- **Object组件化设计**:
  - 每个Object由多个组件组成
  - 组件可复用，便于组合不同Object
  - 使用接口定义通用行为
- **Object生命周期管理**:
  - 统一的对象池管理
  - Object的创建、激活、休眠、销毁
  - 支持Object的状态保存和恢复
- **状态机系统**:
  - 支持状态机接口 `IObjectStateMachine`
  - 提供统一的扩展接口
  - 用于管理Object的不同状态（如可用、损坏、冷却等）

## 实现优先级

### 开发阶段
#### 第一阶段：核心框架
1. 实现核心基础系统（ResourceManager、ConfigManager、EventManager、ObjectPoolManager）
2. 实现Actor基类和Object基类
3. 实现基础的ActorData、ActorConfig和ObjectData、ObjectConfig
4. 创建状态机和Buff系统的接口定义
5. 实现核心管理器单例（ActorManager、ObjectManager、UIManager）

#### 第二阶段：具体Actor和Object
1. 实现ActorMain类（主角）
2. 实现Monster类基础版本
3. 实现基础Object类（物品、建筑、工具）
4. 实现基础工具类和扩展方法
5. 测试基础功能

#### 第三阶段：扩展系统
1. 完整实现状态机系统
2. 完整实现Buff系统
3. 根据需要扩展更多Actor类型
4. 根据需要扩展更多Object类型

#### 第四阶段：集成和优化
1. 集成各个系统和模块
2. 性能优化和内存管理
3. 添加调试和编辑器工具

## 协作规范

### 技术文档生成规范
- **当用户提问"生成某某的技术文档"时，必须严格基于本.cursorrules文件中已有的规则和规范**
- 技术文档内容必须遵循项目的架构设计、代码风格、命名约定等所有既定规范
- 文档中的代码示例必须符合Unity特定规范和性能优化要求
- 引用项目中现有的代码实现方式作为参考标准
- 保持与项目整体技术栈和开发模式的一致性
- 文档结构应包含：概述、系统架构、文件清单、核心组件设计、具体实现、使用示例、性能优化、测试验证、注意事项等完整内容
- **生成技术文档时要求精简，只实现核心模块，避免过度设计和复杂架构，专注于用户需求的核心功能**
- **设计文档中必须明确标注哪些脚本需要挂载到GameObject上使用，区分MonoBehaviour组件和纯数据类/工具类的使用方式**

### 技术文档结构规范
- **文件清单位置**: 技术文档中的"文件清单"部分必须紧跟在"系统架构"部分之后，位于"核心组件设计"之前
- **文件清单内容**: 按照重要性分类：核心脚本（必需）、扩展脚本（可选）、示例脚本，并标注每个文件的用途
- **文档章节顺序**: 概述 → 系统架构 → 文件清单 → 核心组件设计 → 具体实现 → 使用示例 → 性能优化 → 测试验证 → 注意事项
- **便于开发流程**: 开发者在了解架构后立即知道需要创建哪些文件，提高开发效率和文档实用性

### 文档存放规范
- **SetDocument文件夹**：存放用于指导AI实现的技术文档
  - 用途：为AI提供具体的实现指导和技术规范
  - 内容：详细的系统设计、实现要求、代码规范等
  - 目标：确保AI按照统一标准生成代码和文档
- **GetDocument文件夹**：存放AI生成的功能文档
  - 用途：保存AI根据SetDocument指导生成的技术文档
  - 内容：完整的系统文档、使用说明、API文档等
  - 目标：为开发者提供可用的技术文档
- **文档命名规范**：
  - 格式：`功能名称_TechnicalDocument.md` 或 `功能名称_README.md`
  - 使用PascalCase命名，如 `UIList_TechnicalDocument.md`
  - 包含创建日期和版本信息（在文档内容中标注） 