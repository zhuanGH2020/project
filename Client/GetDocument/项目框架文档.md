# 项目框架文档

**版本**: 2.0  
**创建日期**: 2024年12月  
**更新日期**: 2024年12月  

## 目录
- [1. 项目概述](#1-项目概述)
- [2. 核心架构](#2-核心架构)
- [3. 对象系统](#3-对象系统)
- [4. 状态管理系统](#4-状态管理系统)
- [5. 战斗系统](#5-战斗系统)
- [6. 采集交互系统](#6-采集交互系统)
- [7. 装备系统](#7-装备系统)
- [8. 配置系统](#8-配置系统)
- [9. 事件系统](#9-事件系统)
- [10. 使用指南](#10-使用指南)
- [11. 扩展指南](#11-扩展指南)

---

## 1. 项目概述

### 1.1 项目简介
本项目是一个基于Unity的游戏开发框架，采用组件化、接口驱动的设计理念，提供完整的对象管理、战斗、采集、装备等游戏系统。框架设计注重可扩展性和可维护性，适用于RPG、生存、建造等多种游戏类型。

### 1.2 核心特性
- **接口驱动设计**: 使用接口定义行为，提供良好的扩展性
- **组件化架构**: 每个功能模块职责清晰，便于维护
- **数据驱动配置**: 配置表驱动的装备和采集系统
- **自动化管理**: 对象自动注册/反注册机制
- **完整状态管理**: 支持复杂行为的状态机系统
- **统一冷却系统**: 避免重复实现的计时器组件

### 1.3 技术栈
- **引擎**: Unity 2021.3+
- **语言**: C#
- **架构模式**: 组件化 + 接口驱动
- **配置系统**: CSV配置表 + 代码生成

---

## 2. 核心架构

### 2.1 架构图
```
ObjectBase (基类)
├── DamageableObject (可承伤基类)
    ├── CombatEntity (战斗实体)
    │   ├── Player (玩家)
    │   └── Monster (怪物)
    ├── Building (建筑物)
    └── HarvestableObject (可采集物)
        ├── DirectHarvestable (直接采集)
        └── RepeatableHarvestable (可重复采集)

ObjectManager (对象管理器) ←→ ObjectBase
ObjectState (状态管理) ←→ StateBase (状态基类)
```

### 2.2 核心接口
- **IDamageable**: 可承受伤害
- **IAttacker**: 可发起攻击
- **IEquipable**: 可装备物品
- **IHarvestable**: 可采集资源
- **IClickable**: 可点击交互

### 2.3 设计原则
1. **单一职责**: 每个类只负责一个功能
2. **开闭原则**: 对扩展开放，对修改封闭
3. **接口隔离**: 使用接口定义行为契约
4. **依赖倒置**: 依赖抽象而非具体实现

---

## 3. 对象系统

### 3.1 ObjectBase 基类
**位置**: `Assets/Scripts/Object/Base/ObjectBase.cs`

```csharp
public abstract class ObjectBase : MonoBehaviour
{
    public int Uid { get; }                    // 唯一标识符
    public ObjectType ObjectType { get; }      // 对象类型
    public Vector3 Position { get; }           // 世界位置
    
    // 生命周期自动管理
    protected virtual void OnEnable() => ObjectManager.Instance?.Register(this);
    protected virtual void OnDisable() => ObjectManager.Instance.Unregister(this);
}
```

**功能**:
- 提供全局唯一标识符
- 自动注册到对象管理器
- 提供对象类型分类
- 状态系统集成接口

### 3.2 ObjectManager 对象管理器
**位置**: `Assets/Scripts/Manager/ObjectManager.cs`

```csharp
public class ObjectManager
{
    public static ObjectManager Instance { get; }
    
    // 核心功能
    public void Register(ObjectBase obj);
    public void Unregister(ObjectBase obj);
    public ObjectBase FindByUid(int uid);
    public T FindByUid<T>(int uid) where T : ObjectBase;
    public IEnumerable<ObjectBase> FindAllByType(ObjectType type);
    public IEnumerable<T> FindAllByType<T>(ObjectType type) where T : ObjectBase;
}
```

**使用示例**:
```csharp
// 查找玩家
var player = ObjectManager.Instance.FindAllByType<Player>(ObjectType.Player).FirstOrDefault();

// 查找所有怪物
var monsters = ObjectManager.Instance.FindAllByType<Monster>(ObjectType.Monster);

// 根据UID查找对象
var building = ObjectManager.Instance.FindByUid<Building>(buildingId);
```

### 3.3 对象类型枚举
```csharp
public enum ObjectType
{
    Other = 0,      // 其他对象
    Player = 1,     // 玩家角色
    Monster = 2,    // 怪物和敌对生物
    Building = 3,   // 建筑物和构造物
    Item = 4,       // 可采集物品和掉落物
}
```

---

## 4. 状态管理系统

### 4.1 ObjectState 状态管理器
**位置**: `Assets/Scripts/Object/State/ObjectState.cs`

```csharp
public class ObjectState : MonoBehaviour
{
    public bool IsWorking { get; }              // 是否正在工作
    
    public void StartState(StateBase state);   // 开始状态
    public void EndState();                     // 结束状态
}
```

### 4.2 StateBase 状态基类
**位置**: `Assets/Scripts/Object/State/StateBase.cs`

```csharp
public abstract class StateBase : MonoBehaviour
{
    public bool IsActive { get; }
    
    public virtual void EnterState();          // 进入状态
    public virtual void ExitState();           // 退出状态
    public virtual void Tick();                // 状态更新
}
```

### 4.3 内置状态类型
**位置**: `Assets/Scripts/Object/State/States.cs`

- **StateIdle**: 空闲状态
- **StateMove**: 移动状态
- **StateAttack**: 攻击状态
- **StateDead**: 死亡状态

### 4.4 使用示例
```csharp
// 获取状态组件
var objectState = GetComponent<ObjectState>();

// 切换到移动状态
var moveState = gameObject.GetOrAddComponent<StateMove>();
objectState.StartState(moveState);

// 检查是否正在工作
if (objectState.IsWorking)
{
    // 状态正在运行
}
```

---

## 5. 战斗系统

### 5.1 IDamageable 可承伤接口
**位置**: `Assets/Scripts/Object/Interface/IDamageable.cs`

```csharp
public interface IDamageable
{
    float MaxHealth { get; }                    // 最大生命值
    float CurrentHealth { get; }                // 当前生命值
    float Defense { get; }                      // 防御值
    float TakeDamage(DamageInfo damageInfo);    // 承受伤害
}
```

### 5.2 IAttacker 攻击者接口
**位置**: `Assets/Scripts/Object/Interface/IAttacker.cs`

```csharp
public interface IAttacker
{
    float BaseAttack { get; }                   // 基础攻击力
    bool CanAttack { get; }                     // 是否可以攻击
    void PerformAttack(IDamageable target);     // 执行攻击
}
```

### 5.3 DamageInfo 伤害信息
**位置**: `Assets/Scripts/Object/Data/DamageInfo.cs`

```csharp
public struct DamageInfo
{
    public float Damage;                        // 伤害值
    public DamageType Type;                     // 伤害类型
    public Vector3 HitPoint;                    // 击中点
    public Vector3 Direction;                   // 伤害方向
    public IAttacker Source;                    // 伤害来源
}
```

### 5.4 CombatEntity 战斗实体
**位置**: `Assets/Scripts/Object/Base/CombatEntity.cs`

```csharp
public abstract class CombatEntity : DamageableObject, IAttacker
{
    public float BaseAttack { get; }            // 基础攻击力
    public float TotalAttack { get; }           // 总攻击力(含装备)
    public override float Defense { get; }      // 总防御力(含装备)
    public bool CanAttack { get; }              // 攻击冷却检查
    
    public virtual void PerformAttack(IDamageable target);
    public virtual void Equip(int equipId);    // 装备物品
}
```

### 5.5 使用示例
```csharp
// 创建伤害信息
var damageInfo = new DamageInfo
{
    Damage = 50f,
    Type = DamageType.Physical,
    HitPoint = hitPosition,
    Direction = attackDirection,
    Source = attacker
};

// 造成伤害
target.TakeDamage(damageInfo);
```

---

## 6. 采集交互系统

### 6.1 IHarvestable 可采集接口
**位置**: `Assets/Scripts/Object/Interface/IHarvestable.cs`

```csharp
public interface IHarvestable
{
    bool CanHarvest { get; }                    // 是否可采集
    HarvestInfo GetHarvestInfo();               // 获取采集信息
    void OnHarvest(IAttacker harvester);        // 执行采集
}
```

### 6.2 IClickable 可点击接口
```csharp
public interface IClickable
{
    bool CanInteract { get; }                   // 是否可交互
    void OnClick(Vector3 clickPosition);        // 处理点击
    float GetInteractionRange();                // 获取交互范围
}
```

### 6.3 HarvestInfo 采集信息
**位置**: `Assets/Scripts/Object/Data/HarvestData.cs`

```csharp
public struct HarvestInfo
{
    public List<DropItem> drops;                // 掉落物品列表
    public float harvestTime;                   // 采集时间
    public bool destroyAfterHarvest;            // 采集后是否销毁
    public ActionType actionType;               // 动作类型
    public bool requiresTool;                   // 是否需要工具
    public ToolType requiredToolType;           // 需要的工具类型
}
```

### 6.4 DropItem 掉落物品
```csharp
[System.Serializable]
public struct DropItem
{
    public int itemId;                          // 物品ID
    public int minCount;                        // 最小掉落数量
    public int maxCount;                        // 最大掉落数量
    public float dropRate;                      // 掉落概率
    
    public int GetActualDropCount();            // 计算实际掉落数量
}
```

### 6.5 采集对象类型
- **DirectHarvestable**: 直接采集物（草、花等）
- **RepeatableHarvestable**: 可重复采集物（果树等）
- **ToolRequiredHarvestable**: 需要工具的采集物（矿石等）

### 6.6 使用示例
```csharp
// 创建掉落配置
var drops = new List<DropItem>
{
    new DropItem(itemId: 1001, minCount: 1, maxCount: 3, dropRate: 0.8f),
    new DropItem(itemId: 1002, minCount: 1, maxCount: 1, dropRate: 0.3f)
};

// 创建采集信息
var harvestInfo = new HarvestInfo(drops, harvestTime: 2f, 
    destroyAfterHarvest: true, actionType: ActionType.Pick);
```

---

## 7. 装备系统

### 7.1 IEquipable 可装备接口
**位置**: `Assets/Scripts/Object/Interface/IEquipable.cs`

```csharp
public interface IEquipable
{
    float MaxDurability { get; }                // 最大耐久度
    float CurrentDurability { get; }            // 当前耐久度
    bool IsEquipped { get; }                    // 是否已装备
    bool CanUse { get; }                        // 是否可以使用
    
    void OnEquip(IAttacker owner);              // 装备时调用
    void OnUnequip();                           // 卸下时调用
    void Use();                                 // 使用装备
    float GetAttackBonus();                     // 获取攻击加成
    float GetDefenseBonus();                    // 获取防御加成
}
```

### 7.2 EquipBase 装备基类
**位置**: `Assets/Scripts/Object/Equip/Base/EquipBase.cs`

```csharp
public abstract class EquipBase : MonoBehaviour, IEquipable
{
    public EquipPart EquipPart { get; }         // 装备部位
    public float Damage { get; }                // 攻击力
    public float Defense { get; }               // 防御力
    public float Range { get; }                 // 攻击范围
    
    public virtual void Init(int configId);     // 初始化装备
    public virtual void Use();                  // 使用装备
}
```

### 7.3 装备类型枚举
```csharp
public enum EquipPart
{
    None = 0,       // 无
    Head = 1,       // 头部
    Body = 2,       // 身体
    Hand = 3,       // 手部
}

public enum EquipType
{
    None = 0,       // 无
    Helmet = 1,     // 头盔
    Armor = 2,      // 护甲
    Axe = 3,        // 斧头
    Torch = 4,      // 火把
    Uzi = 5,        // 冲锋枪
    Shotgun = 6,    // 散弹枪
}
```

### 7.4 具体装备类型
- **HandEquipBase**: 手持装备基类
- **BodyEquipBase**: 身体装备基类
- **HeadEquipBase**: 头部装备基类

### 7.5 使用示例
```csharp
// 装备物品
var combatEntity = GetComponent<CombatEntity>();
combatEntity.Equip(equipId: 3001); // 装备斧头

// 使用手持装备
var handEquip = combatEntity.GetEquipByPart(EquipPart.Hand);
if (handEquip != null && handEquip.CanUse)
{
    handEquip.Use();
}
```

---

## 8. 配置系统

### 8.1 ConfigManager 配置管理器
**位置**: `Assets/Scripts/Core/Config/ConfigManager.cs`

```csharp
public class ConfigManager
{
    public static ConfigManager Instance { get; }
    
    public ConfigReader GetReader(string configName);
    public void LoadAllConfigs();
}
```

### 8.2 ConfigReader 配置读取器
**位置**: `Assets/Scripts/Core/Config/ConfigReader.cs`

```csharp
public class ConfigReader
{
    public T GetValue<T>(int id, string fieldName, T defaultValue = default);
    public bool HasKey(int id);
    public Dictionary<string, object> GetRow(int id);
}
```

### 8.3 配置表结构
- **Item.csv**: 物品配置
- **Equip.csv**: 装备配置
- **Monster.csv**: 怪物配置
- **Action.csv**: 动作配置
- **Source.csv**: 采集源配置

### 8.4 使用示例
```csharp
// 获取配置读取器
var itemConfig = ConfigManager.Instance.GetReader("Item");

// 读取配置值
string itemName = itemConfig.GetValue<string>(1001, "Name", "未知物品");
float maxHealth = itemConfig.GetValue<float>(1001, "MaxHealth", 100f);
```

---

## 9. 事件系统

### 9.1 EventManager 事件管理器
**位置**: `Assets/Scripts/Core/Event/EventManager.cs`

```csharp
public class EventManager
{
    public static EventManager Instance { get; }
    
    public void Subscribe<T>(System.Action<T> handler) where T : class;
    public void Unsubscribe<T>(System.Action<T> handler) where T : class;
    public void Publish<T>(T eventData) where T : class;
}
```

### 9.2 游戏事件
**位置**: `Assets/Scripts/Core/Event/GameEvents.cs`

- **ObjectInteractionEvent**: 对象交互事件
- **BuildingPlacementModeEvent**: 建筑放置模式事件
- **EquipmentChangeEvent**: 装备变化事件

### 9.3 使用示例
```csharp
// 订阅事件
EventManager.Instance.Subscribe<ObjectInteractionEvent>(OnObjectInteraction);

// 发布事件
var interactionEvent = new ObjectInteractionEvent(target, clickPosition);
EventManager.Instance.Publish(interactionEvent);

// 取消订阅
EventManager.Instance.Unsubscribe<ObjectInteractionEvent>(OnObjectInteraction);
```

---

## 10. 使用指南

### 10.1 创建新的游戏对象

#### 创建玩家角色
```csharp
public class MyPlayer : CombatEntity
{
    protected override void Awake()
    {
        base.Awake();
        SetObjectType(ObjectType.Player);
    }
}
```

#### 创建怪物
```csharp
public class MyMonster : CombatEntity
{
    protected override void Awake()
    {
        base.Awake();
        SetObjectType(ObjectType.Monster);
    }
}
```

#### 创建建筑物
```csharp
public class MyBuilding : Building
{
    protected override void Awake()
    {
        base.Awake();
        SetObjectType(ObjectType.Building);
    }
}
```

#### 创建采集物
```csharp
public class MyHarvestable : HarvestableObject
{
    protected override void Awake()
    {
        base.Awake();
        SetObjectType(ObjectType.Item);
    }
}
```

### 10.2 使用状态系统
```csharp
// 添加状态组件
var objectState = gameObject.GetOrAddComponent<ObjectState>();

// 创建并启动状态
var moveState = gameObject.GetOrAddComponent<StateMove>();
objectState.StartState(moveState);

// 检查状态
if (objectState.IsWorking)
{
    // 对象正在执行状态
}

// 结束状态
objectState.EndState();
```

### 10.3 使用对象管理器
```csharp
// 查找对象
var player = ObjectManager.Instance.FindAllByType<Player>(ObjectType.Player).FirstOrDefault();
var monsters = ObjectManager.Instance.FindAllByType<Monster>(ObjectType.Monster);
var building = ObjectManager.Instance.FindByUid<Building>(buildingId);

// 获取统计信息
int totalObjects = ObjectManager.Instance.GetTotalObjectCount();
int monsterCount = ObjectManager.Instance.GetObjectCountByType(ObjectType.Monster);
```

### 10.4 战斗系统使用
```csharp
// 执行攻击
if (attacker.CanAttack)
{
    attacker.PerformAttack(target);
}

// 装备物品
var combatEntity = GetComponent<CombatEntity>();
combatEntity.Equip(equipId);

// 使用装备
combatEntity.UseHandEquip();
```

### 10.5 采集系统使用
```csharp
// 检查是否可采集
if (harvestable.CanHarvest)
{
    // 执行采集
    harvestable.OnHarvest(harvester);
}

// 处理点击交互
if (clickable.CanInteract)
{
    clickable.OnClick(clickPosition);
}
```

---

## 11. 扩展指南

### 11.1 添加新的对象类型

1. **扩展ObjectType枚举**:
```csharp
public enum ObjectType
{
    // ... 现有类型
    Vehicle = 5,    // 新增载具类型
}
```

2. **创建新的基类**:
```csharp
public class Vehicle : DamageableObject
{
    protected override void Awake()
    {
        base.Awake();
        SetObjectType(ObjectType.Vehicle);
    }
}
```

### 11.2 添加新的状态

1. **创建状态类**:
```csharp
public class StateCustom : StateBase
{
    public override void EnterState()
    {
        base.EnterState();
        // 进入状态逻辑
    }

    public override void Tick()
    {
        // 状态更新逻辑
    }

    public override void ExitState()
    {
        // 退出状态逻辑
        base.ExitState();
    }
}
```

### 11.3 添加新的接口

1. **定义接口**:
```csharp
public interface ICustomBehavior
{
    void CustomAction();
    bool CanPerformCustomAction { get; }
}
```

2. **实现接口**:
```csharp
public class CustomObject : ObjectBase, ICustomBehavior
{
    public bool CanPerformCustomAction => true;
    
    public void CustomAction()
    {
        // 自定义行为实现
    }
}
```

### 11.4 添加新的装备类型

1. **扩展枚举**:
```csharp
public enum EquipType
{
    // ... 现有类型
    Shield = 7,     // 新增盾牌
}

public enum EquipPart
{
    // ... 现有部位
    OffHand = 4,    // 新增副手
}
```

2. **创建装备类**:
```csharp
public class Shield : EquipBase
{
    protected override void ApplyEquipEffect()
    {
        // 盾牌装备效果
    }

    public override void Use()
    {
        base.Use();
        // 盾牌使用逻辑
    }
}
```

### 11.5 性能优化建议

1. **对象池使用**:
```csharp
// 使用对象池管理频繁创建销毁的对象
var pool = ObjectPoolManager.Instance.GetPool<Bullet>();
var bullet = pool.Get();
```

2. **批量查询优化**:
```csharp
// 缓存查询结果，避免频繁查询
private List<Monster> _cachedMonsters;

private void RefreshMonsterCache()
{
    _cachedMonsters = ObjectManager.Instance.FindAllByType<Monster>(ObjectType.Monster).ToList();
}
```

3. **状态更新优化**:
```csharp
// 使用时间片轮询，避免每帧更新所有状态
private void UpdateStatesInBatches()
{
    // 分批更新状态，减少单帧压力
}
```

---

## 12. 最佳实践

### 12.1 命名规范
- 类名使用 PascalCase：`ObjectManager`, `CombatEntity`
- 方法名使用 PascalCase：`PerformAttack`, `GetHarvestInfo`
- 字段名使用 camelCase + 下划线前缀：`_maxHealth`, `_attackTimer`
- 接口名使用 I 前缀：`IDamageable`, `IAttacker`

### 12.2 代码组织
- 按功能模块组织文件夹结构
- 接口和实现分离
- 数据结构独立文件
- 配置表统一管理

### 12.3 错误处理
```csharp
// 使用空检查和默认值
public T FindByUid<T>(int uid) where T : ObjectBase
{
    var obj = FindByUid(uid);
    return obj as T; // 可能返回null，调用者需要检查
}

// 配置缺失时的处理
var config = ConfigManager.Instance.GetReader("Item");
if (config == null)
{
    Debug.LogError("Item config not found!");
    return;
}
```

### 12.4 调试支持
```csharp
// 添加详细的调试日志
Debug.Log($"[{GetType().Name}] {message}");

// 使用条件编译
#if UNITY_EDITOR
    // 编辑器专用调试代码
#endif
```

---

## 13. 总结

本框架提供了一个完整、可扩展的游戏对象系统，具有以下优势：

1. **高可扩展性**: 接口驱动的设计便于添加新功能
2. **低耦合度**: 组件化架构减少模块间依赖
3. **易于维护**: 清晰的代码结构和完善的文档
4. **性能优化**: 对象池、批量处理等优化手段
5. **数据驱动**: 配置表驱动的灵活配置系统

框架已在实际项目中验证，可以支持复杂的游戏逻辑和大规模的对象管理需求。建议开发者在使用过程中根据具体需求进行适当的定制和扩展。 