# 通用编码规范

## 日志打印规范

### 1. 连续日志合并原则

**规则**：一个方法内遇到连续日志的打印不要分散成一条一条debug.log，尽量放在一条Log打印。

**错误示例**：
```csharp
public void ProcessData(List<Item> items)
{
    Debug.Log("开始处理数据");
    Debug.Log($"数据数量: {items.Count}");
    Debug.Log($"处理时间: {DateTime.Now}");
    
    foreach (var item in items)
    {
        Debug.Log($"处理物品: {item.Name}");
        Debug.Log($"物品ID: {item.Id}");
        Debug.Log($"物品类型: {item.Type}");
    }
    
    Debug.Log("数据处理完成");
}
```

**正确示例**：
```csharp
public void ProcessData(List<Item> items)
{
    Debug.Log($"开始处理数据 - 数量: {items.Count}, 时间: {DateTime.Now}");
    
    foreach (var item in items)
    {
        Debug.Log($"处理物品 - 名称: {item.Name}, ID: {item.Id}, 类型: {item.Type}");
    }
    
    Debug.Log("数据处理完成");
}
```

**优势**：
- 减少日志输出量，提高性能
- 便于阅读和调试
- 降低日志文件大小
- 提供更完整的上下文信息

### 2. 日志格式建议

- 使用有意义的前缀标识不同模块
- 包含关键的上下文信息
- 避免重复的常量字符串

**示例**：
```csharp
// 推荐的日志格式
Debug.Log($"[{GetType().Name}] {methodName} - {details}");
```

### 3. 日志级别限制原则

**规则**：只允许打印错误Log，简单Log不需打印。

**说明**：
- 生产环境中只保留错误和警告级别的日志
- 普通的调试信息（Debug.Log）可以在自测阶段临时使用，但在自测完成后必须确认删除
- 重要的系统状态变化可以使用警告级别记录

**允许的日志类型**：
```csharp
// ✅ 允许 - 错误日志
Debug.LogError($"[{GetType().Name}] 加载配置失败: {ex.Message}");

// ✅ 允许 - 警告日志
Debug.LogWarning($"[{GetType().Name}] 资源未找到，使用默认值: {defaultValue}");

// ⚠️ 自测阶段临时允许 - 普通调试日志（自测完成后必须删除）
Debug.Log($"[{GetType().Name}] 开始处理数据"); // TODO: 自测完成后删除

// ❌ 提交代码时禁止 - 普通调试日志
// Debug.Log($"[{GetType().Name}] 开始处理数据");
```

**建议的错误日志格式**：
```csharp
// 错误日志应包含：模块名、方法名、错误描述、相关参数
Debug.LogError($"[{GetType().Name}] {nameof(MethodName)} - 错误描述: {errorMessage}, 参数: {parameter}");

// 异常日志应包含完整的异常信息
Debug.LogError($"[{GetType().Name}] {nameof(MethodName)} - 异常: {ex}");
```

**自测阶段日志使用建议**：
```csharp
// 自测时可以添加临时调试日志，但要标记清楚
Debug.Log($"[DEBUG] {GetType().Name} - 临时调试信息"); // TODO: 自测完成后删除

// 或者使用条件编译，方便统一管理
#if UNITY_EDITOR || DEBUG_BUILD
Debug.Log($"[DEBUG] {GetType().Name} - 开发调试信息");
#endif
```

**优势**：
- 减少日志噪音，提高性能
- 便于快速定位真正的问题
- 降低日志存储成本
- 提高日志的可读性和价值
- 允许开发阶段灵活调试，确保发布版本干净 