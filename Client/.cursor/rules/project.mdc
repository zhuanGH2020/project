---
description: 
globs: 
alwaysApply: true
---
# 游戏开发主规则文档

# 你是一个Unity游戏开发专家，精通性能和内存优化，深入了解其独特功能以及游戏开发中的常见用例

# 对提出的需求优先按照项目文件中已经提供的接口和数据来构建新的逻辑需求

# 优先从项目中查找可以用来实现需求逻辑的接口和代码例子

## 1. Unity项目规范

### Unity命名约定

- **类名**: PascalCase，如 `PlayerController`, `InventoryManager`
- **公共变量和属性**: PascalCase，如 `Health`, `MaxSpeed`
- **私有变量**: camelCase + 下划线前缀，如 `_health`, `_isGamePaused`
- **方法名**: PascalCase，如 `StartGame()`, `UpdateHealth()`
- **常量**: UPPER_SNAKE_CASE，如 `MAX_HEALTH`, `DEFAULT_SPEED`
- **枚举**: PascalCase，如 `ActorType`, `ObjectState`
- **接口名**: 以I开头，如 `IDamageable`, `IInteractable`
- **文件名**: 与类名一致，如 `PlayerController.cs`
- **命名空间**: PascalCase，项目层级结构，如 `GameProject.Core.Manager`
- **所有公共方法和类**: 必须有XML文档注释（/// <summary>）

### MonoBehaviour规范
- 每个MonoBehaviour只负责一个明确的功能
- 使用 `[SerializeField]` 而不是 `public` 暴露字段
- 使用 `[Header]`, `[Tooltip]` 等特性改善Inspector体验
- 使用 `[Range]` 属性限制数值范围
- 重写 `Awake()`, `Start()`, `Update()` 时调用基类方法
- 缓存Transform等组件提升性能
- 使用事件系统进行组件间通信

### 组件设计
- 优先使用组合而非继承
- 每个组件职责单一，便于测试和复用
- 避免在Update中频繁查找组件
- UI系统遵循MVC模式分离关注点
- 游戏系统使用Manager模式管理

### 性能优化
- 缓存GetComponent结果
- 使用Object Pooling管理频繁创建销毁的对象
- 避免在Update中进行字符串操作
- 使用协程处理延时操作
- 合理使用LOD系统
- 优化渲染：合理使用光照贴图和动态光照
- 资源加载：根据需要实现分块加载和异步加载

## 2. 项目架构

### 架构设计
- **UI系统**: 使用MVC模式，分离数据、视图和控制逻辑
- **游戏系统**: 使用Manager模式，每个系统由专门的Manager管理
- **Actor系统**: 统一管理所有Actor，支持主角和怪物等不同类型
- **Object系统**: 统一管理所有可交互Object，包括物品、建筑、工具等

### 核心系统设计
#### 资源管理系统
- **ResourceManager**: 资源加载管理
  - 资源加载：同步/异步加载
  - 引用计数：跟踪资源引用，自动卸载
  - 资源缓存：已加载资源的缓存管理

#### 对象池系统
- **ObjectPoolManager**: 对象池管理器
  - 分类管理：不同类型对象使用不同对象池
  - 统一接口：提供对象获取和回收的统一接口
  - 生命周期：管理各个对象池的生命周期
  - **管理范围**：统一管理Actor和Object两大系统的对象池

- **ObjectPool**: 对象池
  - 对象复用：减少实例化/销毁开销
  - 多预制体支持：一个池可以管理多种预制体
  - 对象状态管理：自动重置对象状态
  - 超时清理：自动清理长时间未使用的对象

#### 配置系统
- **ConfigManager**: 配置管理器
  - 配置加载：加载CSV和ScriptableObject配置
  - 配置缓存：缓存已加载的配置
  - 配置查询：提供统一的查询接口
  - 配置清理：支持清理单个或所有配置

- **ConfigReader**: 配置读取器
  - 数据解析：解析配置数据
  - 类型转换：支持多种数据类型
  - 错误处理：提供友好的错误提示
  - 默认值：支持默认值返回

- **ConfigDefinition**: 配置定义
  - 表头解析：解析CSV表头信息
  - 类型验证：验证数据类型有效性
  - 支持基础类型、数组类型、枚举类型和Unity类型

#### 事件系统
- **统一事件架构**：所有系统间通信使用统一的事件机制
- **事件类型**：
  - UnityEvent：UI组件和MonoBehaviour内部事件
  - System.Action/Func：纯C#类之间的事件通信
  - 全局事件管理器：用于系统级事件广播和订阅
- **事件命名规范**：On + 动作 + 结果，如 OnHealthChanged, OnItemPickedUp
- **事件生命周期**：订阅时注册，销毁时必须取消订阅避免内存泄漏
- **事件管理器设计**：提供统一的事件注册、广播、取消订阅接口

## 3. 协作规范

### 技术文档生成规范
- **当用户提问"生成某某的技术文档"时，必须严格基于本.cursorrules文件中已有的规则和规范**
- 技术文档内容必须遵循项目的架构设计、代码风格、命名约定等所有既定规范
- 文档中的代码示例必须符合Unity特定规范和性能优化要求
- 引用项目中现有的代码实现方式作为参考标准
- 保持与项目整体技术栈和开发模式的一致性
- 文档结构应包含：概述、系统架构、文件清单、核心组件设计、具体实现、使用示例、性能优化、测试验证、注意事项等完整内容
- **生成技术文档时要求精简，只实现核心模块，避免过度设计和复杂架构，专注于用户需求的核心功能**
- **设计文档中必须明确标注哪些脚本需要挂载到GameObject上使用，区分MonoBehaviour组件和纯数据类/工具类的使用方式**

### 技术文档结构规范
- **文件清单位置**: 技术文档中的"文件清单"部分必须紧跟在"系统架构"部分之后，位于"核心组件设计"之前
- **文件清单内容**: 按照重要性分类：核心脚本（必需）、扩展脚本（可选）、示例脚本，并标注每个文件的用途
- **文档章节顺序**: 概述 → 系统架构 → 文件清单 → 核心组件设计 → 具体实现 → 使用示例 → 性能优化 → 测试验证 → 注意事项
- **便于开发流程**: 开发者在了解架构后立即知道需要创建哪些文件，提高开发效率和文档实用性

### 文档存放规范
- **SetDocument文件夹**：存放用于指导AI实现的技术文档
  - 用途：为AI提供具体的实现指导和技术规范
  - 内容：详细的系统设计、实现要求、代码规范等
  - 目标：确保AI按照统一标准生成代码和文档
- **GetDocument文件夹**：存放AI生成的功能文档
  - 用途：保存AI根据SetDocument指导生成的技术文档
  - 内容：完整的系统文档、使用说明、API文档等
  - 目标：为开发者提供可用的技术文档
- **文档命名规范**：
  - 格式：`功能名称_TechnicalDocument.md` 或 `功能名称_README.md`
  - 使用PascalCase命名，如 `UIList_TechnicalDocument.md`
  - 包含创建日期和版本信息（在文档内容中标注） 
